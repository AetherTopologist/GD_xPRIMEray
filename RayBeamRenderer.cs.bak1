using Godot;
using System;
using System.Collections.Generic;

public partial class RayBeamRenderer : Node3D
{
	[Export] public NodePath CameraPath;
	[Export] public bool UpdateEveryFrame = true;     // set false later for “only when changed”
	[Export] public int StepsPerRay = 64;
	[Export] public float StepLength = 0.25f;         // distance per step
	[Export] public float QuadSize = 0.04f;           // billboard size per sample
	[Export] public float BendScale = 0.12f;          // visual bend strength
	[Export] public float Alpha = 0.50f;              // base alpha
	[Export] public bool StopOnHit = false;
	[Export] public uint CollisionMask = 0xFFFFFFFF;
	[Export] public bool UseIntegratedField = true;
	[Export] public Vector3 FieldCenter = Vector3.Zero;
	[Export] public bool FieldCenterIsCamera = true;
	[Export] public float FieldStrength = 1.0f;       // extra multiplier
	[Export] public bool ColorByField = true;
	[Export] public float FieldColorGain = 0.15f;     // higher = gets “hot” faster
	[Export] public Color HotColor = new Color(0.2f, 1.0f, 1.0f, 1.0f); // cyan-ish glow
	[Export] public int RenderEveryNSteps = 1;        // 1 = every step, 2 = every other, etc.
	[Export] public float MinStepLength = 0.05f;
	[Export] public float MaxStepLength = 0.5f;
	[Export] public float StepAdaptGain = 0.05f;      // how strongly acceleration shrinks step
	// --- Collision robustness (INSIGHT-ish thick segment) ---
	[Export] public int CollisionEveryNSteps = 1;     // 1 = every step, 2 = every other, etc.
	[Export] public float CollisionRadius = 0.03f;    // thickness of beam for hit testing
	[Export] public bool UseSphereSweepCollision = false; // switch between IntersectRay vs IntersectShape
	[Export] public bool UseInsightPlaneFilter = false;
	[Export] public NodePath InsightPlaneNode;        // drag your table body here
	[Export] public float CollisionRaySubdivideThreshold = 0.25f; // meters per sub-ray
	[Export] public int MaxCollisionSubsteps = 16;
	// If true and StopOnHit=true, only render rays that actually hit something.
	[Export] public bool RequireHitToRender = false;
	// --- Debug ---
	[Export] public bool DebugRender = false;
	[Export] public int DebugEveryNRays = 25;           // print 1 line per N rays
	[Export] public bool DebugSetBillboardRejects = false; // prints when SetBillboardInstance skips
	[Export] public int DebugMaxRejectPrints = 10;      // cap reject spam
	[Export] public bool CheckCollisionsEvenIfNotStopping = false;



	private MultiMeshInstance3D _mmi;
	private MultiMesh _mm;
	private StandardMaterial3D _mat;

	private float _lastBeta = float.NaN;
	private float _lastGamma = float.NaN;

	private bool _rebuildInProgress = false;
	private bool _rebuildQueued = false;
	// --- Change detection cache (for smarter updates) ---
	private Vector3 _lastCamPos = new Vector3(float.NaN, float.NaN, float.NaN);
	private float _lastCamFocal = float.NaN;
	private int _lastFieldSourceCount = -1;

	private Plane _insightPlane;
	private bool _hasInsightPlane = false;

	private int _dbgRejectPrints = 0;



	public override async void _Ready()
	{
		_mm = new MultiMesh();
		_mm.TransformFormat = MultiMesh.TransformFormatEnum.Transform3D;
		_mm.UseColors = true;
		_mm.UseCustomData = false;

		_mmi = new MultiMeshInstance3D
		{
			Multimesh = _mm
		};

		// Simple quad for each sample
		var quad = new QuadMesh { Size = new Vector2(1, 1) };
		_mm.Mesh = quad;

		_mat = new StandardMaterial3D
		{
			ShadingMode = BaseMaterial3D.ShadingModeEnum.Unshaded,
			Transparency = BaseMaterial3D.TransparencyEnum.Alpha,
			BlendMode = BaseMaterial3D.BlendModeEnum.Add,
			VertexColorUseAsAlbedo = true,
			AlbedoColor = new Color(1, 1, 1, 1),
			EmissionEnabled = true,
			Emission = new Color(1, 1, 1, 1),
			EmissionEnergyMultiplier = 2.0f
		};

		_mmi.MaterialOverride = _mat;

		AddChild(_mmi);
		await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);
		Rebuild();
	}

	public override void _Process(double delta)
	{
		// If you uncheck UpdateEveryFrame in the inspector, nothing auto-updates.
		if (!UpdateEveryFrame) return;

		var cam = GetCamera();
		if (cam == null) return;

		// Curvature controls on the camera
		float beta  = ReadFloat(cam, "Beta", 0f);
		float gamma = ReadFloat(cam, "Gamma", 2f);

		// You can point this at whatever property you’re actually animating:
		// - "FocalLength" if you’ve added it in a camera script
		// - or use cam.Fov instead and store that here.
		float focal = ReadFloat(cam, "FocalLength", 0f);

		var fieldSources = GetTree().GetNodesInGroup("field_sources");
		int fieldCount = fieldSources.Count;

		bool changed = false;

		// 1) Beta / Gamma changed?
		if (!Mathf.IsEqualApprox(beta, _lastBeta) || !Mathf.IsEqualApprox(gamma, _lastGamma))
			changed = true;

		// 2) Camera position changed?
		if (!IsFinite(_lastCamPos) || cam.GlobalPosition.DistanceTo(_lastCamPos) > 0.001f)
			changed = true;

		// 3) Focal length (or FOV proxy) changed?
		if (float.IsNaN(_lastCamFocal) || !Mathf.IsEqualApprox(focal, _lastCamFocal))
			changed = true;

		// 4) field_sources topology changed (added/removed/moved group members)?
		if (fieldCount != _lastFieldSourceCount)
			changed = true;

		if (!changed)
			return;

		// Update caches now that we know something changed
		_lastCamPos = cam.GlobalPosition;
		_lastCamFocal = focal;
		_lastFieldSourceCount = fieldCount;
		_lastBeta = beta;
		_lastGamma = gamma;

		RequestRebuild();
	}


	private void RequestRebuild()
	{
		if (_rebuildInProgress)
		{
			_rebuildQueued = true;
			return;
		}
		if (_rebuildQueued) return;

		_rebuildQueued = true;
		CallDeferred(nameof(DoRebuildDeferred));
	}

	private async void DoRebuildDeferred()
	{
		_rebuildQueued = false;

		// ✅ Make sure physics state is current before using DirectSpaceState collision queries
		await ToSignal(GetTree(), SceneTree.SignalName.PhysicsFrame);

		Rebuild();
	}

	private Camera3D GetCamera()
	{
		if (CameraPath != null && !CameraPath.IsEmpty)
			return GetNodeOrNull<Camera3D>(CameraPath);

		return GetViewport()?.GetCamera3D();
	}

	private void Rebuild()
	{
		GD.Print("Rebuild ENTER");

		if (_rebuildInProgress) return;
		_rebuildInProgress = true;

		try
		{
			var cam = GetCamera();
			if (cam == null) return;

			RefreshInsightPlane();

			Vector3 center = FieldCenterIsCamera ? cam.GlobalPosition : FieldCenter;

			float beta = ReadFloat(cam, "Beta", 0f);
			float gamma = ReadFloat(cam, "Gamma", 2f);

			_lastBeta = beta;
			_lastGamma = gamma;

			var fieldSources = GetTree().GetNodesInGroup("field_sources");
			GD.Print("RayBeamRenderer: field sources in group = ", fieldSources.Count);
			bool hasSources = fieldSources.Count > 0;

			// Gather emitters
			var emitters = GetTree().GetNodesInGroup("ray_emitters");
			int emitterCount = emitters.Count;
			if (emitterCount == 0)
			{
				_mm.InstanceCount = 0;
				return;
			}
			GD.Print("RayBeamRenderer: emitters in group = ", emitters.Count);

			// Total instances = sum over emitters of (rays * steps)
			int total = 0;
			var emitterList = new List<RayEmitter3D>(emitterCount);

			foreach (var node in emitters)
			{
				if (node is RayEmitter3D e)
				{
					emitterList.Add(e);
					total += Math.Max(1, e.Rays) * (StepsPerRay + 1);
				}
			}

			_mm.InstanceCount = total;
			GD.Print($"RayBeamRenderer: total instances target = {total}");

			// Camera basis for billboarding
			Vector3 camRight = cam.GlobalTransform.Basis.X.Normalized();
			Vector3 camUp = cam.GlobalTransform.Basis.Y.Normalized();
			Vector3 camForward = (-cam.GlobalTransform.Basis.Z).Normalized();

			int idx = 0;
			var rng = new Random(12345); // deterministic for now

			PhysicsDirectSpaceState3D space = GetWorld3D().DirectSpaceState;

			float minStep = Mathf.Min(MinStepLength, MaxStepLength);
			float maxStep = Mathf.Max(MinStepLength, MaxStepLength);
			minStep = Mathf.Max(0.0001f, minStep);

			int hitCount = 0;

			bool capacityExhausted = false;

			foreach (var e in emitterList)
			{
				if (capacityExhausted) break;

				Color baseC = e.RayColor;
				float maxDist = e.MaxDistance;

				int rays = Math.Max(1, e.Rays);
				int rayOrdinal = 0; // counts rays for debug sampling
				float spreadRad = Mathf.DegToRad(e.SpreadDegrees);

				Vector3 origin = e.GlobalTransform.Origin;

				for (int r = 0; r < rays; r++)
				{
					bool rayHit = false;
					rayOrdinal++;

					// Reset reject spam cap per rebuild (optional, keeps logs readable)
					if (rayOrdinal == 1) _dbgRejectPrints = 0;

					//////////////////
					/// 
					bool debugThisRay = DebugRender && (rayOrdinal % Mathf.Max(1, DebugEveryNRays) == 0);

					int renderedThisRay = 0;

					// ✅ Declare hit-state BEFORE any debug prints that use it
					bool hadHit = false;
					Vector3 hitPos = Vector3.Zero;
					int cutoffSampleCount = int.MaxValue; // how many samples to render for this ray
					bool stampedHitMarker = false;        // just in case you want to guard duplicates

					// Collect samples for this ray
					var samplePositions = new List<Vector3>();
					var sampleColors = new List<Color>();

					if (debugThisRay) {
						//GD.Print($"[DBG] Ray {rayOrdinal} entering render: willRender={(!RequireHitToRender || hadHit)}");
						GD.Print($"[DBG] Ray#{rayOrdinal} start RequireHitToRender={RequireHitToRender} StopOnHit={StopOnHit}");
					}

					/////////////////////
					/// 

					// Random direction in a cone around emitter -Z (forward in local space)
					Vector3 localDir;
					if (e.UseFan)
					{
						float yawTotal = Mathf.DegToRad(e.FanYawDegrees);
						float pitch = Mathf.DegToRad(e.FanPitchDegrees);

						float u = (rays == 1) ? 0.0f : (float)r / (rays - 1);
						float yaw = Mathf.Lerp(-yawTotal * 0.5f, yawTotal * 0.5f, u);

						localDir = new Vector3(0, 0, -1);
						localDir = localDir.Rotated(Vector3.Up, yaw);
						localDir = localDir.Rotated(Vector3.Right, pitch);
					}
					else
					{
						localDir = RandomInCone(rng, spreadRad);
					}

					Vector3 dir = (e.GlobalTransform.Basis * localDir).Normalized();

					// Bend direction: perpendicular within camera plane, based on direction relative to screen center.
					float dx = dir.Dot(camRight);
					float dy = dir.Dot(camUp);
					Vector2 d2 = new Vector2(dx, -dy);
					Vector2 d2n = d2.Length() > 1e-6f ? d2 / d2.Length() : Vector2.Right;
					Vector3 bendDir = (camRight * d2n.X + camUp * -d2n.Y).Normalized();

					Vector3 p = origin;
					Vector3 v = dir;

					float traveled = 0.0f;

					int every = Mathf.Max(1, RenderEveryNSteps);
					int ce = Mathf.Max(1, CollisionEveryNSteps);

					for (int s = 0; s <= StepsPerRay; s++)
					{
						Vector3 a = Vector3.Zero;
						Vector3 next = p;

						if (UseIntegratedField)
						{
							if (hasSources)
								a = ComputeAccelerationAtPoint(p, fieldSources, beta, gamma);
							else
							{
								Vector3 rvec = p - center;
								float rr = Mathf.Max(0.001f, rvec.Length());
								a = (-rvec / rr) * (beta * Mathf.Pow(rr, gamma) * BendScale * FieldStrength);
							}

							float aLen = a.Length();

							if (!float.IsFinite(aLen))
							{
								a = Vector3.Zero;
								aLen = 0.0f;
							}
							else if (aLen > 50.0f)
							{
								a = a * (50.0f / aLen);
								aLen = 50.0f;
							}

							float step = Mathf.Clamp(StepLength / (1.0f + aLen * StepAdaptGain), minStep, maxStep);
							v = SafeNormalized(v + a * step, v);
							next = p + v * step;

							traveled += (next - p).Length();
							if (traveled > maxDist)
								break;
						}
						else
						{
							float t = s * StepLength;
							float bend = beta * Mathf.Pow(t, gamma) * BendScale;
							next = origin + dir * t + bendDir * bend;
						}

						float step01 = (StepsPerRay <= 0) ? 0f : (float)s / StepsPerRay;
						float fade = 1.0f - step01;
						fade *= fade;
						float alpha = Alpha * e.Intensity * fade;

						Color c = baseC;
						if (ColorByField)
						{
							float heat = Mathf.Clamp(a.Length() * FieldColorGain, 0f, 1f);
							c = c.Lerp(HotColor, heat);
						}
						c.A = Mathf.Clamp(alpha, 0.0f, 1.0f);

						///////////////////////
						/// 
						// ✅ Store sample first (so even early hit rays still render a trail)
						if ((s % every) == 0)
						{
							samplePositions.Add(p);
							sampleColors.Add(c);
						}

						// --- Collision check (only if StopOnHit OR forced collision debug) ---
						if ((StopOnHit || CheckCollisionsEvenIfNotStopping) && s > 0 && (s % ce) == 0)
						{
							Vector3 segA = p;
							Vector3 segB = next;
							float segLen = (segB - segA).Length();

							if (UseInsightPlaneFilter && _hasInsightPlane)
							{
								if (!SegmentCrossesPlane(segA, segB, _insightPlane, CollisionRadius))
									goto SkipCollision;
							}

							bool didHit = false;
							Vector3 hp = Vector3.Zero;

							if (segLen > 1e-6f)
							{
								if (UseSphereSweepCollision)
									didHit = SweepSegmentHit(space, segA, segB, CollisionMask, CollisionRadius, out hp);
								else
								{
									int sub = 1;
									if (segLen > CollisionRaySubdivideThreshold)
										sub = Mathf.CeilToInt(segLen / CollisionRaySubdivideThreshold);
									sub = Mathf.Clamp(sub, 1, MaxCollisionSubsteps);

									didHit = SubdividedRayHit(space, segA, segB, CollisionMask, sub, out hp);
								}
							}

							if (didHit && !rayHit)
							{
								rayHit = true;
								hadHit = true;
								hitPos = hp;

								hitCount++;
								GD.Print("Beam hit at ", hp);

								// Optional: stamp last sample
								if (samplePositions.Count > 0 && idx < _mm.InstanceCount)
								{
									var prePos = samplePositions[samplePositions.Count - 1];
									var preCol = sampleColors[sampleColors.Count - 1];
									SetBillboardInstance(idx++, prePos, camRight, camUp, camForward, preCol);
									renderedThisRay++;
								}

								// Stamp hit marker
								if (idx < _mm.InstanceCount)
								{
									var hitColor = new Color(1, 0, 0, 1);
									SetBillboardInstance(idx++, hp, camRight, camUp, camForward, hitColor);
									renderedThisRay++;
								}

								if (StopOnHit)
									break;
							}

						SkipCollision:;
						}

						p = next;
						///////////////////////
						/// 
					}

					// Render this ray if we either don't require hits OR we got a hit
					if (!RequireHitToRender || hadHit)
					{
						for (int i = 0; i < samplePositions.Count; i++)
						{
							if (idx >= _mm.InstanceCount)
							{
								capacityExhausted = true;
								break;
							}

							if (idx == 0)
								GD.Print("RayBeamRenderer: first instance placed at ", samplePositions[i]);

							SetBillboardInstance(idx++, samplePositions[i], camRight, camUp, camForward, sampleColors[i]);
						}
					}
				}
			}

			if (DebugRender)
			{
				GD.Print($"[DBG] Rebuild summary: totalTarget={total} idxWritten={idx} instanceCount(beforeTrim)={_mm.InstanceCount} hits={hitCount}");
			}

			// ✅ Always trim to what we actually wrote (prevents stale transforms/colors)
			_mm.InstanceCount = idx;
				
		}
		finally
		{
			_rebuildInProgress = false;
		}

		GD.Print("Rebuild EXIT");
	}

	private void SetBillboardInstance(
		int index,
		Vector3 pos,
		Vector3 camRight,
		Vector3 camUp,
		Vector3 camForward,
		Color c)
	{
		if (_mm == null) return;

		if (index < 0 || index >= _mm.InstanceCount)
		{
			if (DebugRender && DebugSetBillboardRejects && _dbgRejectPrints < DebugMaxRejectPrints)
			{
				_dbgRejectPrints++;
				GD.Print($"[DBG] SetBillboard SKIP: index {index} out of range (InstanceCount={_mm.InstanceCount})");
			}
			return;
		}

		if (!IsFinite(pos))
		{
			if (DebugRender && DebugSetBillboardRejects && _dbgRejectPrints < DebugMaxRejectPrints)
			{
				_dbgRejectPrints++;
				GD.Print($"[DBG] SetBillboard SKIP: pos non-finite: {pos}");
			}
			return;
		}

		float s = QuadSize;

		var basis = new Basis(
			camRight * s,
			camUp * s,
			camForward * s
		);

		if (!IsFinite(basis.X) || !IsFinite(basis.Y) || !IsFinite(basis.Z))
		{
			if (DebugRender && DebugSetBillboardRejects && _dbgRejectPrints < DebugMaxRejectPrints)
			{
				_dbgRejectPrints++;
				GD.Print($"[DBG] SetBillboard SKIP: basis non-finite X={basis.X} Y={basis.Y} Z={basis.Z}");
			}
			return;
		}

		var xform = new Transform3D(basis, pos);
		_mm.SetInstanceTransform(index, xform);
		_mm.SetInstanceColor(index, c);
	}

	private Vector3 ComputeAccelerationAtPoint(
				Vector3 p,
				Godot.Collections.Array<Node> sources,
				float globalBeta,
				float globalGamma) {

		Vector3 aSum = Vector3.Zero;

		foreach (var n in sources)
		{
			if (n is not FieldSource3D fs) continue;
			if (!fs.Enabled) continue;

			Vector3 center = fs.GlobalPosition;
			Vector3 rvec = p - center;

			float rRaw = rvec.Length();
			float soft = Mathf.Max(0.00001f, fs.Softening);

			float r = Mathf.Sqrt(rRaw * rRaw + soft * soft);

			if (fs.MinRadius > 0.0f && r < fs.MinRadius) continue;
			if (fs.MaxRadius > 0.0f && r > fs.MaxRadius) continue;

			Vector3 dir = (-rvec / r);
			if (!fs.Attract) dir = -dir;

			float gamma = fs.OverrideGamma ? fs.Gamma : globalGamma;
			float betaScale = fs.OverrideBetaScale ? fs.BetaScale : 1.0f;

			float amp = globalBeta * betaScale * BendScale * FieldStrength * fs.Strength;

			float mag = 0.0f;

			switch (fs.Profile)
			{
				case FieldSource3D.ProfileType.Power:
					mag = amp * Mathf.Pow(r, gamma);
					break;

				case FieldSource3D.ProfileType.InversePower:
					mag = amp / Mathf.Pow(r, Mathf.Max(0.0001f, gamma));
					break;

				case FieldSource3D.ProfileType.Gaussian:
					{
						float sigma = Mathf.Max(0.0001f, fs.Sigma);
						float x = r / sigma;
						mag = amp * Mathf.Exp(-x * x);
					}
					break;

				case FieldSource3D.ProfileType.Shell:
					{
						float inner = Mathf.Max(0.0f, fs.InnerRadius);
						float outer = Mathf.Max(inner + 0.0001f, fs.OuterRadius);
						float edge = Mathf.Max(0.0001f, fs.EdgeSoftness);

						float wIn = SmoothStep(inner - edge, inner + edge, r);
						float wOut = 1.0f - SmoothStep(outer - edge, outer + edge, r);
						float w = Mathf.Clamp(wIn * wOut, 0.0f, 1.0f);

						mag = amp * w * Mathf.Pow(r, gamma);
					}
					break;
			}

			aSum += dir * mag;
		}

		return aSum;
	}

	private static float SmoothStep(float a, float b, float x)
	{
		float t = Mathf.Clamp((x - a) / (b - a), 0.0f, 1.0f);
		return t * t * (3.0f - 2.0f * t);
	}

	private static float ReadFloat(Node obj, StringName prop, float fallback)
	{
		if (obj == null) return fallback;

		Variant v = obj.Get(prop);
		return v.VariantType switch
		{
			Variant.Type.Float => (float)v,
			Variant.Type.Int => (int)v,
			_ => fallback
		};
	}

	private static Vector3 RandomInCone(Random rng, float coneAngleRad)
	{
		double u = rng.NextDouble();
		double v = rng.NextDouble();

		float cosTheta = Mathf.Lerp(1.0f, Mathf.Cos(coneAngleRad), (float)u);
		float sinTheta = Mathf.Sqrt(Mathf.Max(0f, 1f - cosTheta * cosTheta));
		float phi = Mathf.Tau * (float)v;

		float x = sinTheta * Mathf.Cos(phi);
		float y = sinTheta * Mathf.Sin(phi);
		float z = -cosTheta;

		return new Vector3(x, y, z).Normalized();
	}

	private static bool SegmentCrossesPlane(Vector3 p, Vector3 q, Plane plane, float eps = 0.001f)
	{
		float dp = plane.DistanceTo(p);
		float dq = plane.DistanceTo(q);

		// treat small band around plane as "slab"
		float slab = eps * 10.0f;
		if (Mathf.Abs(dp) <= slab || Mathf.Abs(dq) <= slab)
			return true;

		// sign change => segment crosses infinite plane
		return (dp > 0f) != (dq > 0f);
	}

	private void RefreshInsightPlane()
	{
		_hasInsightPlane = false;
		if (InsightPlaneNode == null || InsightPlaneNode.IsEmpty) return;

		var n = GetNodeOrNull<Node3D>(InsightPlaneNode);
		if (n == null) return;

		Vector3 normal = n.GlobalTransform.Basis.Y.Normalized();
		Vector3 point = n.GlobalPosition;

		_insightPlane = new Plane(normal, point);
		_hasInsightPlane = true;
	}

	private static bool SweepSegmentHit(
						PhysicsDirectSpaceState3D space,
						Vector3 a,
						Vector3 b,
						uint mask,
						float radius,
						out Vector3 hitPos)
	{
		hitPos = Vector3.Zero;

		Vector3 motion = b - a;
		float len = motion.Length();
		if (!float.IsFinite(len) || len <= 1e-6f) return false;

		var sphere = new SphereShape3D { Radius = Mathf.Max(0.0005f, radius) };

		var q = new PhysicsShapeQueryParameters3D
		{
			Shape = sphere,
			Transform = new Transform3D(Basis.Identity, a),
			Motion = motion,
			CollisionMask = mask,
			Margin = 0.0f,
			CollideWithBodies = true,
			CollideWithAreas = true
		};

		float[] res = space.CastMotion(q);
		if (res == null || res.Length < 2) return false;

		float unsafeFrac = res[1];
		if (!float.IsFinite(unsafeFrac)) return false;

		if (unsafeFrac < 1.0f)
		{
			hitPos = a + motion * Mathf.Clamp(unsafeFrac, 0.0f, 1.0f);
			return true;
		}

		return false;
	}

	private static bool SubdividedRayHit(
					PhysicsDirectSpaceState3D space,
					Vector3 a,
					Vector3 b,
					uint mask,
					int maxSubsteps,
					out Vector3 hitPos) {
		hitPos = Vector3.Zero;

		Vector3 d = b - a;
		float len = d.Length();
		if (len <= 1e-6f) return false;

		int steps = Mathf.Clamp(maxSubsteps, 1, 64);
		Vector3 prev = a;

		for (int i = 1; i <= steps; i++)
		{
			float t = (float)i / steps;
			Vector3 cur = a + d * t;

			var rq = PhysicsRayQueryParameters3D.Create(prev, cur, mask);
			rq.CollideWithBodies = true;
			rq.CollideWithAreas = true;
			rq.HitFromInside = true;

			var hit = space.IntersectRay(rq);
			if (hit.Count > 0)
			{
				hitPos = (Vector3)hit["position"];
				return true;
			}

			prev = cur;
		}

		return false;
	}

	private static Vector3 SafeNormalized(Vector3 v, Vector3 fallback)
	{
		float len = v.Length();
		if (!float.IsFinite(len) || len < 1e-8f) return fallback;
		return v / len;
	}

private static bool IsFinite(Vector3 v)
{
	return float.IsFinite(v.X) && float.IsFinite(v.Y) && float.IsFinite(v.Z);
}



}
